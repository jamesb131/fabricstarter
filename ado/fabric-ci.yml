trigger:
  branches: { include: ["main"] }
  paths:    { include: ["/infra/terraform/*", "/fabric/*", "/ado/pipelines/*"] }

parameters:
- name: environmentName
  displayName: Environment
  type: string
  default: dev
  values: [dev, prod]

variables:
  # service connections (ARM) per env
  - name: azureServiceConnection
    ${{ if eq(parameters.environmentName, 'dev') }}:
      value: sc-az-dev
    ${{ if eq(parameters.environmentName, 'prod') }}:
      value: sc-az-prod

  # tfvars path
  - name: tfvarsPath
    value: infra/terraform/envs/${{ parameters.environmentName }}.tfvars

stages:
# -------------------- Stage 1: INFRA (Terraform) --------------------
- stage: Infra
  displayName: "Infra: Terraform (${{ parameters.environmentName }})"
  jobs:
  - job: Terraform
    pool: { vmImage: "ubuntu-latest" }
    steps:
    - checkout: self
      fetchDepth: 0

    - task: TerraformInstaller@1
      inputs:
        terraformVersion: "1.9.5"

    - task: TerraformCLI@1
      displayName: "Terraform Init"
      inputs:
        command: init
        workingDirectory: infra/terraform
        backendType: azurerm
        allowTelemetryCollection: false
        backendServiceArm: $(azureServiceConnection)
        ensureBackend: true
        # optionally specify backend config here (rg/storage/key)

    - task: TerraformCLI@1
      displayName: "Terraform Plan"
      inputs:
        command: plan
        workingDirectory: infra/terraform
        environmentServiceName: $(azureServiceConnection)
        commandOptions: "-var-file=$(tfvarsPath) -out=tfplan"

    - task: TerraformCLI@1
      displayName: "Terraform Apply"
      inputs:
        command: apply
        workingDirectory: infra/terraform
        environmentServiceName: $(azureServiceConnection)
        commandOptions: "tfplan"

    - script: |
        cd infra/terraform
        terraform output -json > tf_outputs.json
      displayName: "Capture Terraform outputs"

    - publish: infra/terraform/tf_outputs.json
      artifact: tf-outputs

# -------------------- Stage 2: APP (Fabric CI/CD) --------------------
- stage: App
  displayName: "App: Deploy Fabric items (${{ parameters.environmentName }})"
  dependsOn: Infra
  jobs:
  - job: FabricDeploy
    pool: { vmImage: "ubuntu-latest" }
    steps:
    - checkout: self
      fetchDepth: 0

    - download: current
      artifact: tf-outputs

    # Pull secrets straight from Key Vault using the same ARM service connection.
    - task: AzureCLI@2
      name: kvfetch
      displayName: "Fetch secrets from Key Vault"
      inputs:
        azureSubscription: $(azureServiceConnection)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          OUT="$(cat $(Pipeline.Workspace)/tf-outputs/tf_outputs.json)"
          KV_NAME=$(echo "$OUT" | jq -r '.key_vault_name.value')
          echo "Using Key Vault: $KV_NAME"

          # Required secrets (created by identity_fabric_cicd module)
          FABRIC_CICD_CLIENT_ID_NAME=$(echo "$OUT" | jq -r '.fabric_cicd_client_id_secret_names.value.client_id')
          FABRIC_CICD_CLIENT_SECRET_NAME=$(echo "$OUT" | jq -r '.fabric_cicd_client_id_secret_names.value.secret')

          AZURE_CLIENT_ID=$(az keyvault secret show --vault-name "$KV_NAME" --name "$FABRIC_CICD_CLIENT_ID_NAME" --query value -o tsv)
          AZURE_CLIENT_SECRET=$(az keyvault secret show --vault-name "$KV_NAME" --name "$FABRIC_CICD_CLIENT_SECRET_NAME" --query value -o tsv)

          echo "##vso[task.setvariable variable=AZURE_CLIENT_ID;issecret=true]$AZURE_CLIENT_ID"
          echo "##vso[task.setvariable variable=AZURE_CLIENT_SECRET;issecret=true]$AZURE_CLIENT_SECRET"

          # Tenant & subscription come from the service connection; export tenant explicitly if you want
          TENANT_ID=$(az account show --query tenantId -o tsv)
          echo "##vso[task.setvariable variable=AZURE_TENANT_ID]$TENANT_ID"

          # Workspace ID: set in variable or use a per-env variable named FABRIC_WORKSPACE_ID_<ENV>
          echo "##vso[task.setvariable variable=ENV_NAME]${{ parameters.environmentName }}"
      env:
        AZURE_DEVOPS_EXT_AZURE_RM_SERVICE_PRINCIPAL_KEY: $(System.AccessToken)

    - task: UsePythonVersion@0
      inputs: { versionSpec: "3.10" }

    - script: |
        python -m pip install --upgrade pip
        pip install fabric-cicd
      displayName: "Install fabric-cicd"

    - script: |
        set -euo pipefail

        # Prepare parameters for this env
        cp fabric/parameter.yml fabric/parameter.effective.yml
        sed -i "s/\${ENV_NAME}/${ENV_NAME}/g" fabric/parameter.effective.yml
        # Option 1: workspace id as pipeline variable group per env
        # Option 2: set FABRIC_WORKSPACE_ID in variables UI or variable group
        test -n "$FABRIC_WORKSPACE_ID" || { echo "FABRIC_WORKSPACE_ID not set"; exit 1; }

        python - <<'PY'
        import os
        from fabric_cicd import FabricWorkspace, publish_all_items

        ws = FabricWorkspace(
            workspace_id=os.environ["FABRIC_WORKSPACE_ID"],
            environment=os.environ.get("ENV_NAME","dev"),
            repository_directory="fabric/Workspaces",
        )

        # Auth via DefaultAzureCredential -> uses AZURE_CLIENT_ID/SECRET/TENANT_ID
        publish_all_items(ws, parameter_file="fabric/parameter.effective.yml")
        PY
      displayName: "Deploy Fabric items"
      env:
        AZURE_TENANT_ID: $(AZURE_TENANT_ID)
        AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
        AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)
        FABRIC_WORKSPACE_ID: $(FABRIC_WORKSPACE_ID)
        ENV_NAME: ${{ parameters.environmentName }}
